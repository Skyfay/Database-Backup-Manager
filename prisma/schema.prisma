generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model AdapterConfig {
  id               String   @id @default(uuid())
  name             String
  type             String
  adapterId        String
  config           String
  metadata         String? // Stores non-sensitive runtime data (e.g., version, connection status)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  jobsDestination  Job[]    @relation("Destination")
  jobsSource       Job[]    @relation("Source")
  jobsNotification Job[]    @relation("Notifications")

  // Caching-Felder für schnelle UI-Anzeige ohne Joins
  lastHealthCheck      DateTime?
  lastStatus           String        @default("ONLINE") // ONLINE, DEGRADED, OFFLINE
  consecutiveFailures  Int           @default(0) // Zähler für Logik (Grün -> Orange -> Rot)

  healthLogs           HealthCheckLog[]
}

model EncryptionProfile {
  id          String   @id @default(cuid())
  name        String
  description String?
  secretKey   String
  jobs        Job[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Job {
  id                  String             @id @default(uuid())
  name                String
  schedule            String
  enabled             Boolean            @default(true)
  sourceId            String
  destinationId       String
  encryptionProfileId String?
  encryptionProfile   EncryptionProfile? @relation(fields: [encryptionProfileId], references: [id])
  compression         String             @default("NONE")
  retention           String             @default("{}") // Stores RetentionPolicy as JSON
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  executions          Execution[]
  destination         AdapterConfig      @relation("Destination", fields: [destinationId], references: [id])
  source              AdapterConfig      @relation("Source", fields: [sourceId], references: [id])
  notifications       AdapterConfig[]    @relation("Notifications")
  notificationEvents  String             @default("ALWAYS") // "ALWAYS", "FAILURE_ONLY", "SUCCESS_ONLY"
}

model Execution {
  id        String    @id @default(uuid())
  jobId     String?
  type      String    @default("Backup")
  status    String
  logs      String
  startedAt DateTime  @default(now())
  endedAt   DateTime?
  size      BigInt?
  path      String?
  metadata  String?
  job       Job?      @relation(fields: [jobId], references: [id])
}

model User {
  id               String     @id
  name             String
  email            String     @unique
  emailVerified    Boolean
  image            String?
  timezone         String     @default("UTC")
  dateFormat       String     @default("P")
  timeFormat       String     @default("p")
  autoRedirectOnJobStart Boolean @default(true)
  createdAt        DateTime
  updatedAt        DateTime
  twoFactorEnabled Boolean?
  passkeyTwoFactor Boolean?   @default(false)
  twoFactor        TwoFactor?
  accounts         Account[]
  passkeys         Passkey[]
  sessions         Session[]
  auditLogs        AuditLog[]
  apiKeys          ApiKey[]

  groupId String?
  group   Group?  @relation(fields: [groupId], references: [id])
}

model SystemSetting {
  key         String   @id
  value       String
  description String?
  updatedAt   DateTime @updatedAt
}

model Group {
  id          String   @id @default(uuid())
  name        String   @unique
  permissions String // Stored as JSON
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  users       User[]
}

model TwoFactor {
  id          String @id
  secret      String
  backupCodes String
  userId      String @unique
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Passkey {
  id           String    @id
  name         String?
  publicKey    String
  userId       String
  credentialID String    @unique
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?
  createdAt    DateTime?
  aaguid       String?
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?
}

model SsoProvider {
  id             String   @id @default(cuid())
  providerId     String   @unique // e.g. "authentik-main"
  type           String   @default("oidc") // "oidc" or "saml"
  domain         String?  // Required by better-auth SSO plugin for email domain matching
  domainVerified Boolean  @default(false) // Required by better-auth for trusted provider status

  // OIDC Specific Fields (Managed by Better-Auth)
  oidcConfig     String?  // JSON string containing issuer, clientId, clientSecret, etc.
  samlConfig     String?  // JSON string containing spMetadata, idpMetadata, etc.

  // Legacy/UI Specific Fields (Kept for UI convenience, synced with oidcConfig)
  issuer         String?
  authorizationEndpoint String?
  tokenEndpoint  String?
  userInfoEndpoint String?
  jwksEndpoint   String?

  // Credentials
  clientId       String?
  clientSecret   String?

  // Custom App Logic
  adapterId      String   // e.g. "authentik", "pocket-id"
  adapterConfig  String?  // JSON string storing the raw inputs used to generate the config (e.g. { "url": "...", "realm": "..." })
  name           String   // Display Name e.g. "Corporate Login"
  enabled        Boolean  @default(true)
  allowProvisioning Boolean @default(true) // Whether to create new users automatically

  userId         String? // Optional: If linked to a specific user (Account Linking) logic, usually null for global SSO

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}


// Log-Eintrag für jeden Prüfzyklus (wird regelmäßig bereinigt)
model HealthCheckLog {
  id              String        @id @default(uuid())
  adapterConfigId String
  status          String        // ONLINE, DEGRADED, OFFLINE
  latencyMs       Int           // Antwortzeit in Millisekunden
  error           String?       // Fehlermeldung falls fehlgeschlagen
  createdAt       DateTime      @default(now())

  adapterConfig   AdapterConfig @relation(fields: [adapterConfigId], references: [id], onDelete: Cascade)

  @@index([adapterConfigId, createdAt])
}

model AuditLog {
  id          String   @id @default(uuid())
  userId      String?  // Nullable because some actions might be system actions or deleted users
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  action      String   // ENUM-like string: "LOGIN", "CREATE", "UPDATE", "DELETE"
  resource    String   // ENUM-like string: "USER", "JOB", "SOURCE", "DESTINATION", "SETTINGS"
  resourceId  String?  // The ID of the affected object

  details     String?  // JSON string storing changes (diff) or connection info
  ipAddress   String?
  userAgent   String?

  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([resource])
  @@index([createdAt])
}

model ApiKey {
  id          String    @id @default(uuid())
  name        String
  prefix      String    // First 8 chars of raw key for UI identification (e.g. "dbm_a3f2")
  hashedKey   String    @unique // SHA-256 hash of the full key
  permissions String    // JSON array of permission strings (same format as Group.permissions)
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt   DateTime? // Optional expiration date
  lastUsedAt  DateTime? // Updated on each successful authentication
  enabled     Boolean   @default(true)
  createdAt   DateTime  @default(now())

  @@index([hashedKey])
  @@index([userId])
}

model StorageSnapshot {
  id              String   @id @default(uuid())
  adapterConfigId String
  adapterName     String
  adapterId       String   // e.g. "local", "s3", "dropbox"
  size            BigInt   @default(0)
  count           Int      @default(0)
  createdAt       DateTime @default(now())

  @@index([adapterConfigId])
  @@index([createdAt])
}
