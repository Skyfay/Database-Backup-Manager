generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model AdapterConfig {
  id               String   @id @default(uuid())
  name             String
  type             String
  adapterId        String
  config           String
  metadata         String? // Stores non-sensitive runtime data (e.g., version, connection status)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  jobsDestination  Job[]    @relation("Destination")
  jobsSource       Job[]    @relation("Source")
  jobsNotification Job[]    @relation("Notifications")
}

model EncryptionProfile {
  id          String   @id @default(cuid())
  name        String
  description String?
  secretKey   String
  jobs        Job[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Job {
  id                  String             @id @default(uuid())
  name                String
  schedule            String
  enabled             Boolean            @default(true)
  sourceId            String
  destinationId       String
  encryptionProfileId String?
  encryptionProfile   EncryptionProfile? @relation(fields: [encryptionProfileId], references: [id])
  compression         String             @default("NONE")
  retention           String             @default("{}") // Stores RetentionPolicy as JSON
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  executions          Execution[]
  destination         AdapterConfig      @relation("Destination", fields: [destinationId], references: [id])
  source              AdapterConfig      @relation("Source", fields: [sourceId], references: [id])
  notifications       AdapterConfig[]    @relation("Notifications")
  notificationEvents  String             @default("ALWAYS") // "ALWAYS", "FAILURE_ONLY", "SUCCESS_ONLY"
}

model Execution {
  id        String    @id @default(uuid())
  jobId     String?
  type      String    @default("Backup")
  status    String
  logs      String
  startedAt DateTime  @default(now())
  endedAt   DateTime?
  size      BigInt?
  path      String?
  metadata  String?
  job       Job?      @relation(fields: [jobId], references: [id])
}

model User {
  id               String     @id
  name             String
  email            String     @unique
  emailVerified    Boolean
  image            String?
  timezone         String     @default("UTC")
  dateFormat       String     @default("P")
  timeFormat       String     @default("p")
  createdAt        DateTime
  updatedAt        DateTime
  twoFactorEnabled Boolean?
  passkeyTwoFactor Boolean?   @default(false)
  twoFactor        TwoFactor?
  accounts         Account[]
  passkeys         Passkey[]
  sessions         Session[]

  groupId String?
  group   Group?  @relation(fields: [groupId], references: [id])

  @@map("user")
}

model SystemSetting {
  key         String   @id
  value       String
  description String?
  updatedAt   DateTime @updatedAt
}

model Group {
  id          String   @id @default(uuid())
  name        String   @unique
  permissions String // Stored as JSON
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  users       User[]
}

model TwoFactor {
  id          String @id
  secret      String
  backupCodes String
  userId      String @unique
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Passkey {
  id           String    @id
  name         String?
  publicKey    String
  userId       String
  credentialID String    @unique
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?
  createdAt    DateTime?
  aaguid       String?
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("passkey")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}



model SsoProvider {
  id             String   @id @default(cuid())
  providerId     String   @unique // e.g. "authentik-main"
  type           String   @default("oidc") // "oidc" or "saml"
  
  // OIDC Specific Fields (Managed by Better-Auth)
  issuer         String?
  authorizationEndpoint String?
  tokenEndpoint  String?
  userInfoEndpoint String?
  jwksEndpoint   String?
  
  // Credentials
  clientId       String?
  clientSecret   String? 
  
  // Custom App Logic
  adapterId      String   // e.g. "authentik", "pocket-id"
  name           String   // Display Name e.g. "Corporate Login"
  enabled        Boolean  @default(true)
  
  userId         String? // Optional: If linked to a specific user (Account Linking) logic, usually null for global SSO
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("sso_provider")
}
